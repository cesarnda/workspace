\documentclass[tikz, 12pt]{scrartcl}
\usepackage{etex}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{amsmath}
\usepackage{subfig}
\usepackage[ruled,vlined, linesnumbered]{algorithm2e}
\usepackage{fancyhdr}
\usepackage{anysize}
\usepackage{vaucanson-g}
\usepackage{amsthm}
\usepackage{longtable}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{tkz-fct}
\usetikzlibrary{arrows}
\usepackage{pgfplots}
\usepackage{listings}
\usepackage{color}

\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\title{Data Structures and Algorithms}
\subtitle{Spring 2014}
\author{Cesar Agustin Garcia Vazquez}
\date{\today}                                           % Activate to display a given date or no date
\allowdisplaybreaks
\begin{document}
\maketitle
\section{Programming Assignment 03}

\subsection{Introduction}

For this programming assignment, you will implement a number of heuristics for solving the NUMBER PARTITION problem, which is (of course) NP-complete. As input, the number partition problem takes a sequence $A = (a_1, a_2, \ldots, a_n)$ of non-negative integers. The output is a sequence $S = (s_1, s_2, \ldots, s_n)$ of signs $s_i \in \{ -1, +1 \}$ such that the \textit{residue}, is as shown in equation (\ref{residue}), is minimized.

\begin{equation}\label{residue}
u = \left| \sum_{i = 1}^n s_i \cdot a_i \right|
\end{equation}

Another way to view the problem is the goal is to split the set (or multi-set) of numbers given by $A$ into two subsets $A_1$ and $A_2$ which roughly equal sums. The absolute value of the difference of the sums is the residue.\\
\\
In this programming assignment, we are going to analyze and implement several heuristic methods to solve this problem.

\subsection{Number Partition in $O(n \cdot b)$}

As a warm-up exercise, you will first prove that even though Number Partition is NP-complete, it can be solved in pseudo-polynomial time. That is, suppose the sequence of terms in $A$ sum up to some number $b$. Then each of the numbers in $A$ has at most $\log b$ bits, so a polynomial time algorithm would take time polynomial in $n \cdot \log b$. Instead you should find a dynamic programming algorithm that takes time polynomial in $n \cdot b$.

\subsection{Karmarkar-Karp Algorithm}

One deterministic heuristic for the Number Partition problem is the Karmarkar-Karp algorithm, or the KK algorithm. This approach uses \textit{differencing}. The differencing idea is to take two elements from $A$, call them $a_i$ and $a_j$, and replace the larger by $|a_i - a_j|$ while replacing the smaller by 0. The intuition is that if we decided to put $a_i$ and $a_j$ in different sets, then it is as though we have one element of size $|a_i - a_j|$ around. An algorithm based on differencing repeatedly takes two elements from $A$ and performs a differencing until there is only one element left; this element equals an attainable residue. (A sequence of signs $s_i$ that yields this residue can be determined from the differencing operations performed in linear time by two-coloring the graph $(A, E)$ that arises, where $E$ is the set of pairs $(a_i, a_j)$ that are used in the differencing steps. You will not need to construct the $s_i$ for this assignment.)\\
\\
For the Karmarkar-Karp algorithm suggests repeatedly taking the largest two elements remaining in $A$ at each step and differencing them. For example, if $A$ is initially $(10, 8, 7, 6, 5)$, then the KK algorithm proceeds as in equation (\ref{exampleKK}).

\begin{equation}\label{exampleKK}
\centering
\begin{array}{ccc}
(10, 8, 7, 6, 5)	&	\rightarrow &	(2, 0, 7, 6, 5) \\
				&	\rightarrow	&	(2, 0, 1, 0, 5) \\
				&	\rightarrow &	(0, 0, 1, 0, 3) \\
				&	\rightarrow &	(0, 0, 0, 0, 2)
\end{array}
\end{equation}

Hence the KK algorithm returns a residue of 2. The best possible residue for the example is 0.\\
\\
The fact that we are required to take the largest two elements in each step gives a hint of a sorting involved. If we have $n$ elements, then sorting is going to take $O(n \log n)$. After each sorting, we remove the two largest element and insert the new nonzero value. If we have a sorted linked list, the insertion is going to be in $O(n)$, and for each step, we remove 2 elements and we add 1, so we are reducing the set by 1. Hence, we have the recurrence $T(n) = T(n - 1) + n + 1$ , which considers at most $n - 2$ comparisons to find the sorted place for the new element, as well as retrieving the two largest elements from the sorted linked list, which is done in 2 operations and another operation for the difference. The recurrence 
can be solved by the characteristic equation method, considering the polynomial in equation (\ref{naiveKK}).

\begin{equation}\label{naiveKK}
(x - 1)(x - 1)^2 = (x - 1)^3
\end{equation}

The polynomial in (\ref{naiveKK}) has only one root of multiplicity 3, so the proposed solution for the recurrence is shown in equation (\ref{proposedSolutionForNaiveKK}).

\begin{equation}\label{proposedSolutionForNaiveKK}
T(n)	=	c_1 + c_2 n + c_3 n^2
\end{equation}

Considering the base case for $T(1) = 1$, which just returns the only element in the set, then $T(2) = 4$ and $T(3) = 8$ and the general solution (\ref{proposedSolutionForNaiveKK}), we get the linear system of equations in equation (\ref{linearSystemForNaiveKK}).

\begin{equation}\label{linearSystemForNaiveKK}
\begin{array}{ccccccc}
c_1		&	+	&	c_2		&	+	&	c_3		&	=	&	1\\
c_1		&	+	&	2c_2	&	+	&	4c_3	&	=	&	4\\
c_1		&	+	&	3c_2	&	+	&	9c_3	&	=	&	8
\end{array}
\end{equation}

The linear system in equation (\ref{linearSystemForNaiveKK}) can be solved using Gauss as shown in (\ref{stepsToSolveSystemForNaiveKK}).

\begin{equation}\label{stepsToSolveSystemForNaiveKK}
			\begin{split}
				\begin{array}{cccccc}
					\left(
					\begin{array}{ccc|c}
						1	&	1	&	1	&	1 \\
						1	&	2	&	4	&	4 \\
						1	&	3	&	9	&	8 \\
					\end{array}
					\right)
					&
					\begin{array}{c}
									\\
					R_2 - R_1		 \\
					R_3 - R_1		\\
					\end{array}
					&
					\begin{array}{c}
					 \\
					 \sim\\
					 \\
					\end{array}
					&
					\left(
					\begin{array}{ccc|c}
						1	&	1	&	1	&	1 \\
						0	&	1	&	3	&	3 \\
						0	&	2	&	8	&	7 \\
					\end{array}
					\right)
					&
					\begin{array}{c}
								\\
								 \\
					R_3 - 2R_2	\\
					\end{array}
					&
					\begin{array}{c}
					 \\
					 \sim\\
					 \\
					\end{array}
					\\
					\\
					% Second row
					\left(
					\begin{array}{ccc|c}
						1	&	1	&	1	&	1 \\
						0	&	1	&	3	&	3 \\
						0	&	0	&	2	&	1 \\
					\end{array}
					\right)
					&
					\begin{array}{c}
									\\
								 \\
					\frac{1}{2}R_3 		\\
					\end{array}
					&
					\begin{array}{c}
					 \\
					 \sim\\
					 \\
					\end{array}
					&
					\left(
					\begin{array}{ccc|c}
						1	&	1	&	1	&	1 \\
						0	&	1	&	3	&	3 \\
						0	&	0	&	1	&	\frac{1}{2}\\
					\end{array}
					\right)
					&
					\begin{array}{c}
								\\
					R_2 - 3R_3			 \\
						\\
					\end{array}
					&
					\begin{array}{c}
					 \\
					 \sim\\
					 \\
					\end{array}
					\\
					\\
					% third row
					\left(
					\begin{array}{ccc|c}
						1	&	1	&	1	&	1 \\
						0	&	1	&	0	&	\frac{3}{2} \\
						0	&	0	&	1	&	\frac{1}{2} \\
					\end{array}
					\right)
					&
					\begin{array}{c}
					R_1 - R_3				\\
								 \\
							\\
					\end{array}
					&
					\begin{array}{c}
					 \\
					 \sim\\
					 \\
					\end{array}
					&
					\left(
					\begin{array}{ccc|c}
						1	&	1	&	0	&	\frac{1}{2} \\
						0	&	1	&	0	&	\frac{3}{2} \\
						0	&	0	&	1	&	\frac{1}{2}\\
					\end{array}
					\right)
					&\begin{array}{c}
					R_1 - R_2			\\
								 \\
							\\
					\end{array}
										&
					\begin{array}{c}
					 \\
					 \sim\\
					 \\
					\end{array}
					\\
					\\
					\left(
					\begin{array}{ccc|c}
						1	&	0	&	0	&	-1 \\
						0	&	1	&	0	&	\frac{3}{2} \\
						0	&	0	&	1	&	\frac{1}{2}\\
					\end{array}
					\right)
					\\
				\end{array}
				\end{split}
			\end{equation}

Based on the reduced form yielded in (\ref{stepsToSolveSystemForNaiveKK}), we get that $c_1 = -1$, $c_2 = 3/2$ and $c_3 = 1/2$, which means that the recurrence is given exactly by equation (\ref{exactlyNaiveKK}).

\begin{equation}\label{exactlyNaiveKK}
T(n) = \frac{1}{2} n^2 + \frac{3}{2} n - 1
\end{equation}

We proceed to compute the first 3 values of (\ref{exactlyNaiveKK}) to verify that they match $T(1)$, $T(2)$ and $T(3)$, which is shown in equations (\ref{verifyNaiveKKT1}), (\ref{verifyNaiveKKT2}) and (\ref{verifyNaiveKKT3})

\begin{equation}\label{verifyNaiveKKT1}
\begin{array}{ccc}
T(1)	&	=	&	\frac{1}{2}(1)^2 + \frac{3}{2}(1) - 1 \\	
		&	=	& 	\frac{1}{2} + \frac{3}{2} - \frac{2}{2} \\
		&	=	&	\frac{2}{2} \\
		&	=	&	1
\end{array}
\end{equation}

\begin{equation}\label{verifyNaiveKKT2}
\begin{array}{ccc}
T(2)	&	=	&	\frac{1}{2}(2)^2 + \frac{3}{2}(2) - 1 \\	
		&	=	& 	\frac{1}{2}(4) + \frac{6}{2} - \frac{2}{2} \\
		&	=	& 	\frac{4}{2} + \frac{6}{2} - \frac{2}{2} \\
		&	=	&	\frac{8}{2} \\
		&	=	&	4
\end{array}
\end{equation}

\begin{equation}\label{verifyNaiveKKT3}
\begin{array}{ccc}
T(3)	&	=	&	\frac{1}{2}(3)^2 + \frac{3}{2}(3) - 1 \\	
		&	=	& 	\frac{1}{2}(9) + \frac{9}{2} - \frac{2}{2} \\
		&	=	& 	\frac{9}{2} + \frac{9}{2} - \frac{2}{2} \\
		&	=	&	\frac{16}{2} \\
		&	=	&	8
\end{array}
\end{equation}

As induction hypothesis, we assume that the solution is true, so we have to prove that the recurrence equation is also valid for $n + 1$, which is done in equation (\ref{proofNaiveKK}).

\begin{equation}\label{proofNaiveKK}
\begin{array}{ccl}
T(n + 1) 	&	= 	&	T(n) + n + 2 \\
			&	=	&	\frac{1}{2}n^2 + \frac{3}{2}n - 1 + n + 2\\
			&	=	&	\frac{1}{2}n^2 + n + \frac{1}{2} + \frac{3}{2}n + \frac{3}{2} - 1 \\
			&	=	&	\frac{1}{2}(n^2 + 2n + 1) + \frac{3}{2}(n + 1) - 1 \\
			&	=	&	\frac{1}{2}(n + 1)^2 + 	\frac{3}{2}(n + 1) - 1
\end{array}
\end{equation}

Therefore, the suggested approach has a running time of $O(n^2)$.\\
\\
The algorithm in each step takes two elements and yields another 2 but we are going to consider only the nonzero, so we can place back into the set $A$ the nonzero element, reducing the size of the set by 1. If we want to reduce the running time of the algorithm, we can consider the general recurrence $T(n) = T(n - 1) + O(f(n))$, where $O(f(n))$ is the running time for deleting the two largest elements and inserting the new one. \\
Using a linked list, $f(n) = n$, which means that we must use a data structure which allows to delete an element and insert a new one in running time better than $O(n)$.

\end{document}  